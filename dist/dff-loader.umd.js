(function(K,w){typeof exports=="object"&&typeof module<"u"?w(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],w):(K=typeof globalThis<"u"?globalThis:K||self,w(K.DFFLoader={},K.THREE))})(this,(function(K,w){"use strict";function O(L){const s=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(L){for(const e in L)if(e!=="default"){const a=Object.getOwnPropertyDescriptor(L,e);Object.defineProperty(s,e,a.get?a:{enumerable:!0,get:()=>L[e]})}}return s.default=L,Object.freeze(s)}const m=O(w),C={CHUNK_NAOBJECT:0,CHUNK_STRUCT:1,CHUNK_STRING:2,CHUNK_EXTENSION:3,CHUNK_CAMERA:5,CHUNK_TEXTURE:6,CHUNK_MATERIAL:7,CHUNK_MATERIALLIST:8,CHUNK_ATOMICSECT:9,CHUNK_PLANESECT:10,CHUNK_WORLD:11,CHUNK_SPLINE:12,CHUNK_MATRIX:13,CHUNK_FRAMELIST:14,CHUNK_GEOMETRY:15,CHUNK_CLUMP:16,CHUNK_LIGHT:18,CHUNK_UNICODESTRING:19,CHUNK_ATOMIC:20,CHUNK_TEXTURENATIVE:21,CHUNK_TEXDICTIONARY:22,CHUNK_ANIMDATABASE:23,CHUNK_IMAGE:24,CHUNK_SKINANIMATION:25,CHUNK_GEOMETRYLIST:26,CHUNK_ANIMANIMATION:27,CHUNK_HANIMANIMATION:27,CHUNK_TEAM:28,CHUNK_CROWD:29,CHUNK_RIGHTTORENDER:31,CHUNK_MTEFFECTNATIVE:32,CHUNK_MTEFFECTDICT:33,CHUNK_TEAMDICTIONARY:34,CHUNK_PITEXDICTIONARY:35,CHUNK_TOC:36,CHUNK_PRTSTDGLOBALDATA:37,CHUNK_ALTPIPE:38,CHUNK_PIPEDS:39,CHUNK_PATCHMESH:40,CHUNK_CHUNKGROUPSTART:41,CHUNK_CHUNKGROUPEND:42,CHUNK_UVANIMDICT:43,CHUNK_COLLTREE:44,CHUNK_ENVIRONMENT:45,CHUNK_COREPLUGINIDMAX:46,CHUNK_MORPH:261,CHUNK_SKYMIPMAP:272,CHUNK_SKIN:278,CHUNK_PARTICLES:280,CHUNK_HANIM:286,CHUNK_MATERIALEFFECTS:288,CHUNK_PDSPLG:305,CHUNK_ADCPLG:308,CHUNK_UVANIMPLG:309,CHUNK_BINMESH:1294,CHUNK_NATIVEDATA:1296,CHUNK_VERTEXFORMAT:1296,CHUNK_PIPELINESET:39056115,CHUNK_SPECULARMAT:39056118,CHUNK_2DFX:39056120,CHUNK_NIGHTVERTEXCOLOR:39056121,CHUNK_COLLISIONMODEL:39056122,CHUNK_REFLECTIONMAT:39056124,CHUNK_MESHEXTENSION:39056125,CHUNK_FRAME:39056126},b={rwTEXTURED:4,rwPRELIT:8,rwTEXTURED2:128,rwNATIVE:16777216};class B{constructor(){this.data=null,this.position=0}parse(s){for(this.data=new DataView(s),this.position=0;this.position<s.byteLength;){const e=this.readChunk(C.CHUNK_CLUMP);if(e)return e}return null}readHeader(s){const e={type:this.readUInt32(),length:0,build:0,version:0};return e.name=this.getChunkName(e.type),e.length=this.readUInt32(),e.build=this.readUInt32(),e.build&4294901760?e.version=e.build>>14&261888|e.build>>16&63|196608:e.version=e.build<<8,s!==void 0&&(e.parent=s),e}getChunkName(s){for(const e in C)if(C[e]===s)return e;return"CHUNK_UNKNOWN"}checkBounds(s){if(this.position+s>this.data.byteLength)throw new Error(`DFFLoader: Buffer overflow at position ${this.position} (need ${s} bytes, have ${this.data.byteLength-this.position})`)}readInt32(){this.checkBounds(4);const s=this.data.getInt32(this.position,!0);return this.position+=4,s}readUInt32(){this.checkBounds(4);const s=this.data.getUint32(this.position,!0);return this.position+=4,s}readUInt16(){this.checkBounds(2);const s=this.data.getUint16(this.position,!0);return this.position+=2,s}readUInt8(){this.checkBounds(1);const s=this.data.getUint8(this.position);return this.position+=1,s}readFloat32(){this.checkBounds(4);const s=this.data.getFloat32(this.position,!0);return this.position+=4,s}readString(s){let e="";const a=this.position+s;for(;this.position<a;){const r=this.data.getUint8(this.position++);if(r===0){this.position=a;break}e+=String.fromCharCode(r)}return e.trim()}readChunk(s,e){const a=this.position,r=this.readHeader(e);if(s!==r.type)return s!==C.CHUNK_CLUMP&&console.error(`DFFLoader: Chunk "${this.getChunkName(s)}" not found at position ${a}`),this.position+=r.length,null;const o=this.position,i=this.readData(r);if(this.position<o+r.length)console.warn(`DFFLoader: Chunk ${r.name} not read to end`),this.position=o+r.length;else if(this.position>o+r.length)throw new Error(`DFFLoader: Offset is outside the bounds of chunk ${r.name}`);return i}readData(s){let e=null;switch(s.type){case C.CHUNK_CLUMP:{const a=this.readHeader(),r=this.readUInt32();a.length===12&&(this.readUInt32(),this.readUInt32()),e={RWFrameList:this.readChunk(C.CHUNK_FRAMELIST),RWGeometryList:this.readChunk(C.CHUNK_GEOMETRYLIST),RWAtomicList:[]};for(let o=0;o<r;o++)e.RWAtomicList[o]=this.readChunk(C.CHUNK_ATOMIC);this.readExtension(e);break}case C.CHUNK_FRAMELIST:{this.readHeader();const a=this.readUInt32();e=new Array(a);for(let r=0;r<a;r++){const o={rotationMatrix:[this.readFloat32(),this.readFloat32(),this.readFloat32(),this.readFloat32(),this.readFloat32(),this.readFloat32(),this.readFloat32(),this.readFloat32(),this.readFloat32()],position:[this.readFloat32(),this.readFloat32(),this.readFloat32()],parentIndex:this.readInt32(),flags:this.readUInt32()};e[r]={RWFrame:o}}for(let r=0;r<a;r++)this.readExtension(e[r]);break}case C.CHUNK_GEOMETRYLIST:{this.readHeader();const a=this.readUInt32();e=new Array(a);for(let r=0;r<a;r++)e[r]=this.readChunk(C.CHUNK_GEOMETRY);break}case C.CHUNK_GEOMETRY:{const a=this.readHeader();this.position,e={format:this.readUInt32(),numTriangles:this.readUInt32(),numVertices:this.readUInt32(),numMorphTargets:this.readUInt32()};let r=e.format>>16&255;r===0&&e.format&b.rwTEXTURED&&(r=1),console.log(`DFFLoader: Geometry - format: 0x${e.format.toString(16)}, verts: ${e.numVertices}, tris: ${e.numTriangles}, morphs: ${e.numMorphTargets}, UVs: ${r}`),console.log(`DFFLoader: Flags - native: ${!!(e.format&b.rwNATIVE)}, prelit: ${!!(e.format&b.rwPRELIT)}, textured: ${!!(e.format&b.rwTEXTURED)}, textured2: ${!!(e.format&b.rwTEXTURED2)}`),a.version<212992&&(e.ambient=this.readFloat32(),e.specular=this.readFloat32(),e.diffuse=this.readFloat32());const o=(e.format&b.rwNATIVE)!==0;if(!o){if(e.format&b.rwPRELIT){e.prelitcolor=new Array(e.numVertices);for(let t=0;t<e.numVertices;t++)e.prelitcolor[t]={r:this.readUInt8(),g:this.readUInt8(),b:this.readUInt8(),a:this.readUInt8()};console.log(`DFFLoader: Read ${e.numVertices} vertex colors`)}if(e.format&(b.rwTEXTURED|b.rwTEXTURED2)){e.texCoords=new Array(r);for(let t=0;t<r;t++){e.texCoords[t]=new Array(e.numVertices);for(let n=0;n<e.numVertices;n++)e.texCoords[t][n]={u:this.readFloat32(),v:this.readFloat32()}}console.log(`DFFLoader: Read ${r} UV sets`)}e.triangles=new Array(e.numTriangles);const i=new Set;for(let t=0;t<e.numTriangles;t++){const n=this.readUInt16(),x=this.readUInt16(),p=this.readUInt16(),U=this.readUInt16();t<5&&console.log("Triangle "+t+" raw: ["+n+", "+x+", "+p+", "+U+"]"),e.triangles[t]={vertex2:n,vertex1:x,materialId:p,vertex3:U},i.add(e.triangles[t].materialId)}console.log("DFFLoader: Read "+e.numTriangles+" triangles, unique materialIds:",[...i])}e.morphTargets=new Array(e.numMorphTargets);for(let i=0;i<e.numMorphTargets;i++)if(e.morphTargets[i]={boundingSphere:{x:this.readFloat32(),y:this.readFloat32(),z:this.readFloat32(),radius:this.readFloat32()},hasVertices:0,hasNormals:0},!o){if(e.morphTargets[i].hasVertices=this.readUInt32(),e.morphTargets[i].hasNormals=this.readUInt32(),e.morphTargets[i].hasVertices){e.morphTargets[i].vertices=new Array(e.numVertices);for(let t=0;t<e.numVertices;t++)e.morphTargets[i].vertices[t]={x:this.readFloat32(),y:this.readFloat32(),z:this.readFloat32()}}if(e.morphTargets[i].hasNormals){e.morphTargets[i].normals=new Array(e.numVertices);for(let t=0;t<e.numVertices;t++)e.morphTargets[i].normals[t]={x:this.readFloat32(),y:this.readFloat32(),z:this.readFloat32()}}}console.log(`DFFLoader: Read ${e.numMorphTargets} morph targets, position now: ${this.position}`),e.RWMaterialList=this.readChunk(C.CHUNK_MATERIALLIST),this.readExtension(e);break}case C.CHUNK_MATERIALLIST:{this.readHeader();const a=this.readUInt32();e=new Array(a);for(let r=0;r<a;r++)e[r]={id:this.readUInt32()};for(let r=0;r<a;r++)e[r].RWMaterial=this.readChunk(C.CHUNK_MATERIAL);break}case C.CHUNK_MATERIAL:{const a=this.readHeader();e={flags:this.readUInt32(),color:{r:this.readUInt8(),g:this.readUInt8(),b:this.readUInt8(),a:this.readUInt8()}},this.readUInt32(),e.isTextured=this.readUInt32(),a.version>197632&&(e.ambient=this.readFloat32(),e.specular=this.readFloat32(),e.diffuse=this.readFloat32()),e.isTextured&&(e.RWTexture=this.readChunk(C.CHUNK_TEXTURE)),this.readExtension(e);break}case C.CHUNK_TEXTURE:{this.readHeader(),e={filterFlags:this.readUInt16()},this.readUInt16(),e.name=this.readChunk(C.CHUNK_STRING),e.maskName=this.readChunk(C.CHUNK_STRING),this.readExtension(e);break}case C.CHUNK_STRING:e=this.readString(s.length);break;case C.CHUNK_ATOMIC:{this.readHeader(),e={frameIndex:this.readUInt32(),geometryIndex:this.readUInt32(),flags:this.readUInt32()},this.readUInt32(),this.readExtension(e);break}case C.CHUNK_EXTENSION:{e={};const a=this.position+s.length;for(;this.position<a;){const r=this.readHeader();let o={};const i=this.position;switch(r.type){case C.CHUNK_HANIM:if(o={hAnimVersion:this.readUInt32(),nodeId:this.readUInt32(),numNodes:this.readUInt32()},o.numNodes){o.flags=this.readUInt32(),o.keyFrameSize=this.readUInt32(),o.nodes=new Array(o.numNodes);for(let t=0;t<o.numNodes;t++)o.nodes[t]={nodeId:this.readUInt32(),nodeIndex:this.readUInt32(),flags:this.readUInt32()}}break;case C.CHUNK_FRAME:o=this.readString(r.length);break;case C.CHUNK_BINMESH:{o={faceType:this.readUInt32()};const t=this.readUInt32();o.numIndices=this.readUInt32(),o.splits=new Array(t);const n=r.length>12+t*8;for(let x=0;x<t;x++){const p=this.readUInt32();if(o.splits[x]={numIndices:p,matIndex:this.readUInt32()},n){o.splits[x].indices=new Array(p);for(let U=0;U<p;U++)o.splits[x].indices[U]=this.readUInt32()}}break}case C.CHUNK_SKIN:{o={numBones:this.readUInt8(),numUsedBones:this.readUInt8(),maxWeightsPerVertex:this.readUInt8(),padding:this.readUInt8()},o.bonesUsed=new Array(o.numUsedBones);for(let n=0;n<o.numUsedBones;n++)o.bonesUsed[n]=this.readUInt8();const t=s.parent.numVertices;o.vertexBoneIndices=new Array(t);for(let n=0;n<t;n++)o.vertexBoneIndices[n]={x:this.readUInt8(),y:this.readUInt8(),z:this.readUInt8(),w:this.readUInt8()};o.vertexBoneWeights=new Array(t);for(let n=0;n<t;n++)o.vertexBoneWeights[n]={x:this.readFloat32(),y:this.readFloat32(),z:this.readFloat32(),w:this.readFloat32()};o.skinToBoneMatrix=new Array(o.numBones);for(let n=0;n<o.numBones;n++){o.numUsedBones===0&&(this.position+=4),o.skinToBoneMatrix[n]=[];for(let x=0;x<16;x++)o.skinToBoneMatrix[n][x]=this.readFloat32()}o.numUsedBones!==0&&(this.position+=12);break}case C.CHUNK_MESHEXTENSION:{if(this.readUInt32()===0)break;console.warn("DFFLoader: MESHEXTENSION not fully implemented"),this.position=i+r.length;break}default:this.position+=r.length;break}this.position<i+r.length&&(console.warn(`DFFLoader: Extension ${r.name} not read to end`),this.position=i+r.length),e[r.name]&&console.warn(`DFFLoader: Duplicate extension ${r.name}`),e[r.name]=o}break}default:console.warn(`DFFLoader: Unknown chunk type ${s.name}`);break}return e}readExtension(s){s.RWExtension=this.readChunk(C.CHUNK_EXTENSION,s)}}class k extends m.Loader{constructor(s){super(s),this.textureDictionary=null}setTextureDictionary(s){return this.textureDictionary=s,this}load(s,e,a,r){const o=new m.FileLoader(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(s,i=>{try{e(this.parse(i))}catch(t){r?r(t):console.error(t),this.manager.itemError(s)}},a,r)}parse(s){const e=new B,a=new m.Group,r=e.parse(s);if(!r)return console.warn("DFFLoader: No clump found in file"),a;const o=[];return r.RWGeometryList.forEach(i=>{var A;const t=new m.BufferGeometry,n=(A=i.RWExtension)==null?void 0:A.CHUNK_BINMESH;let x=[];if(n&&n.splits&&n.splits.length>0)if(n.splits.some(h=>h.indices&&h.indices.length>0))n.splits.forEach((h,u)=>{if(h.indices&&h.indices.length>0){const F=[];if(n.faceType===0)for(let N=0;N<h.indices.length;N+=3)F.push([h.indices[N],h.indices[N+1],h.indices[N+2]]);else for(let N=0;N<h.indices.length-2;N++)N%2===0?F.push([h.indices[N],h.indices[N+1],h.indices[N+2]]):F.push([h.indices[N+1],h.indices[N],h.indices[N+2]]);x.push({matIndex:h.matIndex,triangles:F})}});else{let h=0;n.splits.forEach((u,F)=>{const N=Math.floor((u.numIndices||0)/3),I=[];for(let H=0;H<N&&h+H<i.triangles.length;H++){const S=i.triangles[h+H];I.push([S.vertex1,S.vertex2,S.vertex3])}I.length>0&&x.push({matIndex:u.matIndex,triangles:I}),h+=N})}if(x.length===0){const R={};i.triangles.forEach(h=>{const u=h.materialId||0;R[u]||(R[u]=[]),R[u].push([h.vertex1,h.vertex2,h.vertex3])});for(const[h,u]of Object.entries(R))x.push({matIndex:Number(h),triangles:u})}const p=x.reduce((R,h)=>R+h.triangles.length,0),U=new m.BufferAttribute(new Float32Array(p*3*3),3),f=i.morphTargets[0].hasNormals?new m.BufferAttribute(new Float32Array(p*3*3),3):null,_=!!i.prelitcolor,d=_?new m.BufferAttribute(new Float32Array(p*3*4),4):null,g=i.texCoords?new m.BufferAttribute(new Float32Array(p*3*2),2):null;let l=0;const M={};for(const R of x){const h=l;for(const u of R.triangles)for(const F of u){const N=i.morphTargets[0].vertices[F];if(U.setXYZ(l,N.x,N.y,N.z),M[F]=M[F]||[],M[F].push(l),f){const I=i.morphTargets[0].normals[F];f.setXYZ(l,I.x,I.y,I.z)}if(g){const I=i.texCoords[0][F];g.setXY(l,I.u,I.v)}if(d){const I=i.prelitcolor[F];d.setXYZW(l,I.r/255,I.g/255,I.b/255,I.a/255)}l++}t.addGroup(h,l-h,R.matIndex)}t.setAttribute("position",U),f?t.setAttribute("normal",f):t.computeVertexNormals(),d&&t.setAttribute("color",d),g&&t.setAttribute("uv",g),t.computeBoundingSphere();const E=i.RWMaterialList.map(R=>{const h=R.RWMaterial,u=new m.MeshStandardMaterial({vertexColors:_,roughness:h.diffuse!==void 0?h.diffuse:.8,metalness:.1,color:new m.Color(h.color.r/255,h.color.g/255,h.color.b/255),transparent:h.color.a<255,opacity:h.color.a/255});if(h.isTextured&&h.RWTexture){const F=h.RWTexture.name,N=h.RWTexture.maskName;if(console.log(`DFFLoader: Material requests texture "${F}"${N?` (mask: ${N})`:""}`),F&&this.textureDictionary){const I=this.textureDictionary.get(F.toLowerCase());if(I){const H=I.texture||I;u.map=H.clone(),I.hasAlpha&&(u.transparent=!0,u.alphaTest=.1),u.map.needsUpdate=!0,console.log(`DFFLoader: Found TXD texture "${F}"`)}else console.warn(`DFFLoader: Texture "${F}" not found in TXD (available: ${this.textureDictionary.size})`)}if(!u.map&&F){const I=new m.TextureLoader;this.path&&I.setPath(this.path),u.map=I.load(F+".png",()=>{u.needsUpdate=!0},void 0,()=>{u.map=I.load(F+".jpg",()=>{u.needsUpdate=!0},void 0,()=>{u.map=I.load(F+".bmp",()=>{u.needsUpdate=!0})})})}if(u.map&&(u.map.wrapS=m.RepeatWrapping,u.map.wrapT=m.RepeatWrapping,u.map.colorSpace=m.SRGBColorSpace),N){if(this.textureDictionary){const I=this.textureDictionary.get(N.toLowerCase());I&&(u.alphaMap=I.clone(),u.alphaMap.needsUpdate=!0)}if(!u.alphaMap){const I=new m.TextureLoader;this.path&&I.setPath(this.path),u.alphaMap=I.load(N+".png",()=>{u.needsUpdate=!0})}u.alphaMap&&(u.alphaMap.wrapS=m.RepeatWrapping,u.alphaMap.wrapT=m.RepeatWrapping,u.transparent=!0,u.alphaTest=.05)}}return u});if(i.RWExtension&&i.RWExtension.CHUNK_SKIN){const R=i.RWExtension.CHUNK_SKIN,h=new m.Float32BufferAttribute(new Float32Array(U.count*4),4),u=new m.Float32BufferAttribute(new Float32Array(U.count*4),4);for(let F=0;F<i.numVertices;F++)M[F]&&M[F].forEach(N=>{const I=R.vertexBoneIndices[F],H=R.vertexBoneWeights[F];h.setXYZW(N,I.x,I.y,I.z,I.w),u.setXYZW(N,H.x,H.y,H.z,H.w)});t.setAttribute("skinIndex",h),t.setAttribute("skinWeight",u)}o.push({geometry:t,materials:E})}),r.RWAtomicList.forEach(i=>{const t=o[i.geometryIndex];if(!t)return;const{geometry:n,materials:x}=t,p=new Array(r.RWFrameList.length);let U=null,T=null;if(r.RWFrameList.forEach((f,_)=>{var M,E;const d=f.RWFrame,c=new m.Bone;c.name=((M=f.RWExtension)==null?void 0:M.CHUNK_FRAME)||`bone_${_}`;const g=new m.Matrix4;g.set(d.rotationMatrix[0],d.rotationMatrix[3],d.rotationMatrix[6],d.position[0],d.rotationMatrix[1],d.rotationMatrix[4],d.rotationMatrix[7],d.position[1],d.rotationMatrix[2],d.rotationMatrix[5],d.rotationMatrix[8],d.position[2],0,0,0,1),c.applyMatrix4(g),d.parentIndex>=0&&p[d.parentIndex]&&p[d.parentIndex].add(c);const l=(E=f.RWExtension)==null?void 0:E.CHUNK_HANIM;l&&(c.userData.nodeId=l.nodeId,c.userData.nodeIndex=_,l.numNodes>0&&(T=c,U=l.nodes.map((A,R)=>({id:A.nodeId,index:R,flags:A.flags,frame:null})))),p[_]=c}),U){const f=new Array(U.length),_=(c,g,l=new Set)=>{if(!c||l.has(c))return null;if(l.add(c),c.userData.nodeId>=0&&c.userData.nodeId===g&&d(c)===-1)return c;for(const E of c.children){const A=_(E,g,l);if(A)return A}const M=c.userData.nodeIndex+1;return M<p.length?_(p[M],g,l):null},d=c=>{for(let g=0;g<U.length;g++)if(U[g].node===c)return g;return-1};for(let c=0;c<U.length;c++)U[c].node=_(T,U[c].id),f[c]=U[c].node;f.every(c=>c!==null)&&(t.skeleton=new m.Skeleton(f))}}),o.forEach(i=>{let t;i.skeleton?(t=new m.SkinnedMesh(i.geometry,i.materials),t.add(i.skeleton.bones[0]),t.bind(i.skeleton)):t=new m.Mesh(i.geometry,i.materials),t.rotation.set(-Math.PI/2,0,Math.PI),a.add(t)}),a}}const y={FORMAT_1555:256,FORMAT_565:512,FORMAT_4444:768,FORMAT_8888:1280,FORMAT_888:1536,FORMAT_EXT_PAL8:8192,FORMAT_EXT_PAL4:16384},D={D3DFMT_A8R8G8B8:21,D3DFMT_X8R8G8B8:22,D3DFMT_R5G6B5:23,D3DFMT_A1R5G5B5:25,D3DFMT_A4R4G4B4:26,D3DFMT_DXT3:861165636,D3DFMT_DXT5:894720068};class X extends m.Loader{constructor(s){super(s),this.textures=new Map}load(s,e,a,r){const o=new m.FileLoader(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(s,i=>{try{e(this.parse(i))}catch(t){r?r(t):console.error(t),this.manager.itemError(s)}},a,r)}parse(s){var o;if(this.arraybuffer=s,this.data=new DataView(s),this.position=0,this.textures=new Map,this.readHeader().type!==C.CHUNK_TEXDICTIONARY)throw new Error("TXDLoader: Not a valid TXD file");this.readHeader();const a=this.readUInt16(),r=this.readUInt16();console.log(`TXDLoader: Loading ${a} textures (device: ${r})`);for(let i=0;i<a;i++)try{const t=this.readTextureNative();t&&(this.textures.set(t.name.toLowerCase(),{texture:t.texture,hasAlpha:t.hasAlpha}),console.log(`TXDLoader: Loaded texture "${t.name}" (${t.width}x${t.height}, compression: ${t.compression}, format: 0x${((o=t.d3dFormat)==null?void 0:o.toString(16))||"N/A"}, alpha: ${t.hasAlpha})`))}catch(t){console.warn(`TXDLoader: Failed to load texture ${i}:`,t.message)}return this.textures}readHeader(){return{type:this.readUInt32(),length:this.readUInt32(),build:this.readUInt32()}}readTextureNative(){const s=this.readHeader();if(s.type!==C.CHUNK_TEXTURENATIVE)return this.position+=s.length,null;const e=this.position+s.length;this.readHeader();const a=this.readUInt32();this.readUInt32();const r=this.readString(32),o=this.readString(32),i=this.readUInt32();let t,n,x,p,U=!1,T=0;if(a===9)T=this.readUInt32(),t=this.readUInt16(),n=this.readUInt16(),this.readUInt8(),x=this.readUInt8(),this.readUInt8(),p=this.readUInt8(),U=T===D.D3DFMT_DXT3||T===D.D3DFMT_DXT5||T===D.D3DFMT_A8R8G8B8||T===D.D3DFMT_A4R4G4B4||T===D.D3DFMT_A1R5G5B5;else if(a===8)U=this.readUInt32()!==0,t=this.readUInt16(),n=this.readUInt16(),this.readUInt8(),x=this.readUInt8(),this.readUInt8(),p=this.readUInt8();else return console.warn(`TXDLoader: Unsupported platform ID: ${a}`),this.position=e,null;const f=(i&y.FORMAT_EXT_PAL8)!==0,_=(i&y.FORMAT_EXT_PAL4)!==0;let d=null;if(f){d=new Uint8Array(256*4);for(let A=0;A<256;A++)d[A*4+2]=this.readUInt8(),d[A*4+1]=this.readUInt8(),d[A*4+0]=this.readUInt8(),d[A*4+3]=this.readUInt8()}else if(_){d=new Uint8Array(64);for(let A=0;A<16;A++)d[A*4+2]=this.readUInt8(),d[A*4+1]=this.readUInt8(),d[A*4+0]=this.readUInt8(),d[A*4+3]=this.readUInt8()}const c=this.readUInt32(),g=new Uint8Array(this.arraybuffer.slice(this.position,this.position+c));this.position+=c;let l;p===1||p===8?l=this.decodeDXT1(g,t,n):p===3||p===9?l=this.decodeDXT3(g,t,n):p===5?l=this.decodeDXT5(g,t,n):f?l=this.decodePal8(g,d,t,n):_?l=this.decodePal4(g,d,t,n):l=this.decodeUncompressed(g,t,n,T,i);for(let A=1;A<x;A++){const R=this.readUInt32();this.position+=R}const M=this.readHeader();this.position+=M.length;const E=new m.DataTexture(l,t,n,m.RGBAFormat,m.UnsignedByteType);return E.name=r,E.wrapS=m.RepeatWrapping,E.wrapT=m.RepeatWrapping,E.magFilter=m.LinearFilter,E.minFilter=m.LinearMipmapLinearFilter,E.generateMipmaps=!0,E.colorSpace=m.SRGBColorSpace,E.flipY=!1,E.needsUpdate=!0,{name:r,alphaName:o,width:t,height:n,hasAlpha:U,compression:p,d3dFormat:T,texture:E}}decodeDXT1(s,e,a){const r=new Uint8Array(e*a*4),o=Math.ceil(e/4),i=Math.ceil(a/4);let t=0;for(let n=0;n<i;n++)for(let x=0;x<o;x++){const p=s[t]|s[t+1]<<8,U=s[t+2]|s[t+3]<<8;t+=4;const T=[];T[0]=this.rgb565ToRgba(p),T[1]=this.rgb565ToRgba(U),p>U?(T[2]=this.interpolateColor(T[0],T[1],1/3),T[3]=this.interpolateColor(T[0],T[1],2/3)):(T[2]=this.interpolateColor(T[0],T[1],.5),T[3]=[0,0,0,0]);const f=s[t]|s[t+1]<<8|s[t+2]<<16|s[t+3]<<24;t+=4;for(let _=0;_<4;_++)for(let d=0;d<4;d++){const c=x*4+d,g=n*4+_;if(c>=e||g>=a)continue;const l=f>>(_*4+d)*2&3,M=T[l],E=(g*e+c)*4;r[E+0]=M[0],r[E+1]=M[1],r[E+2]=M[2],r[E+3]=M[3]}}return r}decodeDXT3(s,e,a){const r=new Uint8Array(e*a*4),o=Math.ceil(e/4),i=Math.ceil(a/4);let t=0;for(let n=0;n<i;n++)for(let x=0;x<o;x++){const p=[];for(let d=0;d<8;d++)p.push(s[t+d]);t+=8;const U=s[t]|s[t+1]<<8,T=s[t+2]|s[t+3]<<8;t+=4;const f=[];f[0]=this.rgb565ToRgba(U),f[1]=this.rgb565ToRgba(T),f[2]=this.interpolateColor(f[0],f[1],1/3),f[3]=this.interpolateColor(f[0],f[1],2/3);const _=s[t]|s[t+1]<<8|s[t+2]<<16|s[t+3]<<24;t+=4;for(let d=0;d<4;d++)for(let c=0;c<4;c++){const g=x*4+c,l=n*4+d;if(g>=e||l>=a)continue;const M=_>>(d*4+c)*2&3,E=f[M],A=d*4+c,R=p[Math.floor(A/2)],h=(A%2===0?R&15:R>>4)*17,u=(l*e+g)*4;r[u+0]=E[0],r[u+1]=E[1],r[u+2]=E[2],r[u+3]=h}}return r}decodeDXT5(s,e,a){const r=new Uint8Array(e*a*4),o=Math.ceil(e/4),i=Math.ceil(a/4);let t=0;for(let n=0;n<i;n++)for(let x=0;x<o;x++){const p=s[t],U=s[t+1];t+=2;let T=0n;for(let l=0;l<6;l++)T|=BigInt(s[t+l])<<BigInt(l*8);t+=6;const f=[p,U];if(p>U)for(let l=1;l<=6;l++)f.push(Math.floor(((7-l)*p+l*U)/7));else{for(let l=1;l<=4;l++)f.push(Math.floor(((5-l)*p+l*U)/5));f.push(0),f.push(255)}const _=s[t]|s[t+1]<<8,d=s[t+2]|s[t+3]<<8;t+=4;const c=[];c[0]=this.rgb565ToRgba(_),c[1]=this.rgb565ToRgba(d),c[2]=this.interpolateColor(c[0],c[1],1/3),c[3]=this.interpolateColor(c[0],c[1],2/3);const g=s[t]|s[t+1]<<8|s[t+2]<<16|s[t+3]<<24;t+=4;for(let l=0;l<4;l++)for(let M=0;M<4;M++){const E=x*4+M,A=n*4+l;if(E>=e||A>=a)continue;const R=g>>(l*4+M)*2&3,h=c[R],u=l*4+M,F=Number(T>>BigInt(u*3)&0x7n),N=f[F],I=(A*e+E)*4;r[I+0]=h[0],r[I+1]=h[1],r[I+2]=h[2],r[I+3]=N}}return r}decodePal8(s,e,a,r){const o=new Uint8Array(a*r*4);for(let i=0;i<a*r;i++){const t=s[i];o[i*4+0]=e[t*4+0],o[i*4+1]=e[t*4+1],o[i*4+2]=e[t*4+2],o[i*4+3]=e[t*4+3]}return o}decodePal4(s,e,a,r){const o=new Uint8Array(a*r*4);for(let i=0;i<a*r;i++){const t=Math.floor(i/2),n=i%2===0?s[t]&15:s[t]>>4;o[i*4+0]=e[n*4+0],o[i*4+1]=e[n*4+1],o[i*4+2]=e[n*4+2],o[i*4+3]=e[n*4+3]}return o}decodeUncompressed(s,e,a,r,o){const i=new Uint8Array(e*a*4),t=o&3840;for(let n=0;n<e*a;n++){let x,p,U,T;if(r===D.D3DFMT_A8R8G8B8||t===y.FORMAT_8888)U=s[n*4+0],p=s[n*4+1],x=s[n*4+2],T=s[n*4+3];else if(r===D.D3DFMT_X8R8G8B8)U=s[n*4+0],p=s[n*4+1],x=s[n*4+2],T=255;else if(t===y.FORMAT_888)U=s[n*3+0],p=s[n*3+1],x=s[n*3+2],T=255;else if(r===D.D3DFMT_R5G6B5||t===y.FORMAT_565){const f=s[n*2]|s[n*2+1]<<8;x=(f>>11&31)*255/31,p=(f>>5&63)*255/63,U=(f&31)*255/31,T=255}else if(r===D.D3DFMT_A1R5G5B5||t===y.FORMAT_1555){const f=s[n*2]|s[n*2+1]<<8;T=f>>15?255:0,x=(f>>10&31)*255/31,p=(f>>5&31)*255/31,U=(f&31)*255/31}else if(r===D.D3DFMT_A4R4G4B4||t===y.FORMAT_4444){const f=s[n*2]|s[n*2+1]<<8;T=(f>>12&15)*17,x=(f>>8&15)*17,p=(f>>4&15)*17,U=(f&15)*17}else U=s[n*4+0]||0,p=s[n*4+1]||0,x=s[n*4+2]||0,T=s[n*4+3]||255;i[n*4+0]=x,i[n*4+1]=p,i[n*4+2]=U,i[n*4+3]=T}return i}rgb565ToRgba(s){const e=(s>>11&31)*255/31,a=(s>>5&63)*255/63,r=(s&31)*255/31;return[Math.round(e),Math.round(a),Math.round(r),255]}interpolateColor(s,e,a){return[Math.round(s[0]+(e[0]-s[0])*a),Math.round(s[1]+(e[1]-s[1])*a),Math.round(s[2]+(e[2]-s[2])*a),255]}readUInt32(){const s=this.data.getUint32(this.position,!0);return this.position+=4,s}readUInt16(){const s=this.data.getUint16(this.position,!0);return this.position+=2,s}readUInt8(){const s=this.data.getUint8(this.position);return this.position+=1,s}readString(s){let e="";for(let a=0;a<s;a++){const r=this.data.getUint8(this.position+a);if(r===0)break;e+=String.fromCharCode(r)}return this.position+=s,e.trim()}getTexture(s){return this.textures.get(s.toLowerCase())}}K.DFFLoader=k,K.TXDLoader=X,Object.defineProperty(K,Symbol.toStringTag,{value:"Module"})}));
